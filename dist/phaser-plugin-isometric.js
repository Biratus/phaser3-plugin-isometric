module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Cube.js":
/*!*********************!*\
  !*** ./src/Cube.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point3 */ \"./src/Point3.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class Cube\n *\n * @classdesc\n * Creates a new Cube object with the bottom-back corner specified by the x, y and z parameters, with the specified breadth (widthX), depth (widthY) and height parameters. If you call this function without parameters, a Cube with x, y, z, breadth, depth and height properties set to 0 is created.\n */\nvar Cube = function () {\n  /**\n   * @constructor\n   * @param {number} x - The x coordinate of the bottom-back corner of the Cube.\n   * @param {number} y - The y coordinate of the bottom-back corner of the Cube.\n   * @param {number} z - The z coordinate of the bottom-back corner of the Cube.\n   * @param {number} widthX - The X axis width (breadth) of the Cube. Should always be either zero or a positive value.\n   * @param {number} widthY - The Y axis width (depth) of the Cube. Should always be either zero or a positive value.\n   * @param {number} height - The Z axis height of the Cube. Should always be either zero or a positive value.\n   * @return {Cube} This Cube object.\n   */\n  function Cube() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var widthX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var widthY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var height = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    _classCallCheck(this, Cube);\n\n    /**\n     * @property {number} x - The x coordinate of the bottom-back corner of the Cube.\n     */\n    this.x = x;\n\n    /**\n     * @property {number} y - The y coordinate of the bottom-back corner of the Cube.\n     */\n    this.y = y;\n\n    /**\n     * @property {number} z - The z coordinate of the bottom-back corner of the Cube.\n     */\n    this.z = z;\n\n    /**\n     * @property {number} widthX - The X axis width (breadth) of the Cube. This value should never be set to a negative.\n     */\n    this.widthX = widthX;\n\n    /**\n     * @property {number} widthY - The Y axis width (depth) of the Cube. This value should never be set to a negative.\n     */\n    this.widthY = widthY;\n\n    /**\n     * @property {number} height - The Z axis height of the Cube. This value should never be set to a negative.\n     */\n    this.height = height;\n\n    /**\n     * @property {Array.<Point3>} _corners - The 8 corners of the Cube.\n     * @private\n     */\n    this._corners = [new _Point2.default(this.x, this.y, this.z), new _Point2.default(this.x, this.y, this.z + this.height), new _Point2.default(this.x, this.y + this.widthY, this.z), new _Point2.default(this.x, this.y + this.widthY, this.z + this.height), new _Point2.default(this.x + this.widthX, this.y, this.z), new _Point2.default(this.x + this.widthX, this.y, this.z + this.height), new _Point2.default(this.x + this.widthX, this.y + this.widthY, this.z), new _Point2.default(this.x + this.widthX, this.y + this.widthY, this.z + this.height)];\n  }\n\n  /**\n   * Sets the members of Cube to the specified values.\n   * @method Cube#setTo\n   * @param {number} x - The x coordinate of the bottom-back corner of the Cube.\n   * @param {number} y - The y coordinate of the bottom-back corner of the Cube.\n   * @param {number} z - The z coordinate of the bottom-back corner of the Cube.\n   * @param {number} widthX - The X axis width (breadth) of the Cube. This value should never be set to a negative.\n   * @param {number} widthY - The Y axis width (depth) of the Cube. This value should never be set to a negative.\n   * @param {number} height - The Z axis height of the Cube. This value should never be set to a negative.\n   * @return {Cube} This Cube object\n   */\n\n\n  _createClass(Cube, [{\n    key: 'setTo',\n    value: function setTo(x, y, z, widthX, widthY, height) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.widthX = widthX;\n      this.widthY = widthY;\n      this.height = height;\n\n      return this;\n    }\n\n    /**\n     * Copies the x, y, z, widthX, widthY and height properties from any given object to this Cube.\n     * @method Cube#copyFrom\n     * @param {any} source - The object to copy from.\n     * @return {Cube} This Cube object.\n     */\n\n  }, {\n    key: 'copyFrom',\n    value: function copyFrom(source) {\n      this.setTo(source.x, source.y, source.z, source.widthX, source.widthY, source.height);\n    }\n\n    /**\n     * Copies the x, y, z, widthX, widthY and height properties from this Cube to any given object.\n     * @method Cube#copyTo\n     * @param {any} dest - The object to copy to.\n     * @return {Cube} This Cube object.\n     */\n\n  }, {\n    key: 'copyTo',\n    value: function copyTo(dest) {\n      dest.x = this.x;\n      dest.y = this.y;\n      dest.z = this.z;\n      dest.widthX = this.widthX;\n      dest.widthY = this.widthY;\n      dest.height = this.height;\n\n      return dest;\n    }\n\n    /**\n     * The size of the Cube object, expressed as a Point3 object with the values of the widthX, widthY and height properties.\n     * @method Cube#size\n     * @param {Point3} [output] - Optional Point3 object. If given the values will be set into the object, otherwise a brand new Point3 object will be created and returned.\n     * @return {Point3} The size of the Cube object.\n     */\n\n  }, {\n    key: 'size',\n    value: function size(output) {\n      return Cube.size(this, output);\n    }\n\n    /**\n     * Determines whether the specified coordinates are contained within the region defined by this Cube object.\n     * @method Cube#contains\n     * @param {number} x - The x coordinate of the point to test.\n     * @param {number} y - The y coordinate of the point to test.\n     * @param {number} y - The z coordinate of the point to test.\n     * @return {boolean} A value of true if the Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(x, y, z) {\n      return Cube.contains(this, x, y, z);\n    }\n\n    /**\n     * Determines whether the specified X and Y coordinates are contained within the region defined by this Cube object.\n     * @method Cube#containsXY\n     * @param {number} x - The x coordinate of the point to test.\n     * @param {number} y - The y coordinate of the point to test.\n     * @return {boolean} A value of true if this Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'containsXY',\n    value: function containsXY(x, y) {\n      return Cube.containsXY(this, x, y);\n    }\n\n    /**\n     * Returns a new Cube object with the same values for the x, y, z, widthX, widthY and height properties as the original Cube object.\n     * @method Cube#clone\n     * @param {Cube} [output] - Optional Cube object. If given the values will be set into the object, otherwise a brand new Cube object will be created and returned.\n     * @return {Cube}\n     */\n\n  }, {\n    key: 'clone',\n    value: function clone(output) {\n      return Cube.clone(this, output);\n    }\n\n    /**\n     * Determines whether the two Cubes intersect with each other.\n     * This method checks the x, y, z, widthX, widthY, and height properties of the Cubes.\n     * @method Cube#intersects\n     * @param {Cube} b - The second Cube object.\n     * @return {boolean} A value of true if the specified object intersects with this Cube object; otherwise false.\n     */\n\n  }, {\n    key: 'intersects',\n    value: function intersects(b) {\n      return Cube.intersects(this, b);\n    }\n\n    /**\n     * Updates and returns an Array of eight Point3 objects containing the corners of this Cube.\n     * @method Cube#getCorners\n     * @return {Array.<Point3>} The corners of this Cube expressed as an Array of eight Point3 objects.\n     */\n\n  }, {\n    key: 'getCorners',\n    value: function getCorners() {\n      this._corners[0].setTo(this.x, this.y, this.z);\n      this._corners[1].setTo(this.x, this.y, this.z + this.height);\n      this._corners[2].setTo(this.x, this.y + this.widthY, this.z);\n      this._corners[3].setTo(this.x, this.y + this.widthY, this.z + this.height);\n      this._corners[4].setTo(this.x + this.widthX, this.y, this.z);\n      this._corners[5].setTo(this.x + this.widthX, this.y, this.z + this.height);\n      this._corners[6].setTo(this.x + this.widthX, this.y + this.widthY, this.z);\n      this._corners[7].setTo(this.x + this.widthX, this.y + this.widthY, this.z + this.height);\n\n      return this._corners;\n    }\n\n    /**\n     * Returns a string representation of this object.\n     * @method Cube#toString\n     * @return {string} A string representation of the instance.\n     */\n\n  }, {\n    key: 'toString',\n    value: function toString() {\n      return '[{Cube (x=' + this.x + ' y=' + this.y + ' z=' + this.z + ' widthX=' + this.widthX + ' widthY=' + this.widthY + ' height=' + this.height + ' empty=' + this.empty + ')}]';\n    }\n\n    /**\n     * @name Cube#halfWidthX\n     * @property {number} halfWidthX - Half of the widthX of the Cube.\n     * @readonly\n     */\n\n  }, {\n    key: 'halfWidthX',\n    get: function get() {\n      return Math.round(this.widthX * 0.5);\n    }\n\n    /**\n     * @name Cube#halfWidthY\n     * @property {number} halfWidthY - Half of the widthY of the Cube.\n     * @readonly\n     */\n\n  }, {\n    key: 'halfWidthY',\n    get: function get() {\n      return Math.round(this.widthY * 0.5);\n    }\n\n    /**\n     * @name Cube#halfHeight\n     * @property {number} halfHeight - Half of the height of the Cube.\n     * @readonly\n     */\n\n  }, {\n    key: 'halfHeight',\n    get: function get() {\n      return Math.round(this.height * 0.5);\n    }\n\n    /**\n     * The z coordinate of the bottom of the Cube. Changing the bottom property of a Cube object has no effect on the x, y, widthX and widthY properties.\n     * However it does affect the height property, whereas changing the z value does not affect the height property.\n     * @name Cube#bottom\n     * @property {number} bottom - The z coordinate of the bottom of the Cube.\n     */\n\n  }, {\n    key: 'bottom',\n    get: function get() {\n      return this.z;\n    },\n    set: function set(value) {\n      if (value >= this.top) {\n        this.height = 0;\n      } else {\n        this.height = this.top - value;\n      }\n      this.z = value;\n    }\n\n    /**\n     * The sum of the z and height properties. Changing the top property of a Cube object has no effect on the x, y, z, widthX and widthY properties, but does change the height property.\n     * @name Cube#top\n     * @property {number} top - The sum of the z and height properties.\n     */\n\n  }, {\n    key: 'top',\n    get: function get() {\n      return this.z + this.height;\n    },\n    set: function set(value) {\n      if (value <= this.z) {\n        this.height = 0;\n      } else {\n        this.height = value - this.z;\n      }\n    }\n\n    /**\n     * The x coordinate of the back of the Cube. Changing the backX property of a Cube object has no effect on the y, z, widthY and height properties. However it does affect the widthX property, whereas changing the x value does not affect the width property.\n     * @name Cube#backX\n     * @property {number} backX - The x coordinate of the left of the Cube.\n     */\n\n  }, {\n    key: 'backX',\n    get: function get() {\n      return this.x;\n    },\n    set: function set(value) {\n      if (value >= this.frontX) {\n        this.widthX = 0;\n      } else {\n        this.widthX = this.frontX - value;\n      }\n      this.x = value;\n    }\n\n    /**\n     * The y coordinate of the back of the Cube. Changing the backY property of a Cube object has no effect on the x, z, widthX and height properties. However it does affect the widthY property, whereas changing the y value does not affect the width property.\n     * @name Cube#backY\n     * @property {number} backY - The x coordinate of the left of the Cube.\n     */\n\n  }, {\n    key: 'backY',\n    get: function get() {\n      return this.y;\n    },\n    set: function set(value) {\n      if (value >= this.frontY) {\n        this.widthY = 0;\n      } else {\n        this.widthY = this.frontY - value;\n      }\n      this.y = value;\n    }\n\n    /**\n     * The sum of the x and widthX properties. Changing the frontX property of a Cube object has no effect on the x, y, z, widthY and height properties, however it does affect the widthX property.\n     * @name Cube#frontX\n     * @property {number} frontX - The sum of the x and widthX properties.\n     */\n\n  }, {\n    key: 'frontX',\n    get: function get() {\n      return this.x + this.widthX;\n    },\n    set: function set(value) {\n      if (value <= this.x) {\n        this.widthX = 0;\n      } else {\n        this.widthX = value - this.x;\n      }\n    }\n\n    /**\n     * The sum of the y and widthY properties. Changing the frontY property of a Cube object has no effect on the x, y, z, widthX and height properties, however it does affect the widthY property.\n     * @name Cube#frontY\n     * @property {number} frontY - The sum of the y and widthY properties.\n     */\n\n  }, {\n    key: 'frontY',\n    get: function get() {\n      return this.y + this.widthY;\n    },\n    set: function set(value) {\n      if (value <= this.y) {\n        this.widthY = 0;\n      } else {\n        this.widthY = value - this.y;\n      }\n    }\n\n    /**\n     * The volume of the Cube derived from widthX * widthY * height.\n     * @name Cube#volume\n     * @property {number} volume - The volume of the Cube derived from widthX * widthY * height.\n     * @readonly\n     */\n\n  }, {\n    key: 'volume',\n    get: function get() {\n      return this.widthX * this.widthY * this.height;\n    }\n\n    /**\n     * The x coordinate of the center of the Cube.\n     * @name Cube#centerX\n     * @property {number} centerX - The x coordinate of the center of the Cube.\n     */\n\n  }, {\n    key: 'centerX',\n    get: function get() {\n      return this.x + this.halfWidthX;\n    },\n    set: function set(value) {\n      this.x = value - this.halfWidthX;\n    }\n\n    /**\n     * The y coordinate of the center of the Cube.\n     * @name Cube#centerY\n     * @property {number} centerY - The y coordinate of the center of the Cube.\n     */\n\n  }, {\n    key: 'centerY',\n    get: function get() {\n      return this.y + this.halfWidthY;\n    },\n    set: function set(value) {\n      this.y = value - this.halfWidthY;\n    }\n\n    /**\n     * The z coordinate of the center of the Cube.\n     * @name Cube#centerZ\n     * @property {number} centerZ - The z coordinate of the center of the Cube.\n     */\n\n  }, {\n    key: 'centerZ',\n    get: function get() {\n      return this.z + this.halfHeight;\n    },\n    set: function set(value) {\n      this.z = value - this.halfHeight;\n    }\n\n    /**\n     * A random value between the frontX and backX values (inclusive) of the Cube.\n     *\n     * @name Cube#randomX\n     * @property {number} randomX - A random value between the frontX and backX values (inclusive) of the Cube.\n     */\n\n  }, {\n    key: 'randomX',\n    get: function get() {\n      return this.x + Math.random() * this.widthX;\n    }\n\n    /**\n     * A random value between the frontY and backY values (inclusive) of the Cube.\n     *\n     * @name Cube#randomY\n     * @property {number} randomY - A random value between the frontY and backY values (inclusive) of the Cube.\n     */\n\n  }, {\n    key: 'randomY',\n    get: function get() {\n      return this.y + Math.random() * this.widthY;\n    }\n\n    /**\n     * A random value between the bottom and top values (inclusive) of the Cube.\n     *\n     * @name Cube#randomZ\n     * @property {number} randomZ - A random value between the bottom and top values (inclusive) of the Cube.\n     */\n\n  }, {\n    key: 'randomZ',\n    get: function get() {\n      return this.z + Math.random() * this.height;\n    }\n\n    /**\n     * Determines whether or not this Cube object is empty. A Cube object is empty if its widthX, widthY or height is less than or equal to 0.\n     * If set to true then all of the Cube properties are set to 0.\n     * @name Cube#empty\n     * @property {boolean} empty - Gets or sets the Cube's empty state.\n     */\n\n  }, {\n    key: 'empty',\n    get: function get() {\n      return !this.widthX || !this.widthY || !this.height;\n    },\n    set: function set(value) {\n      if (value === true) {\n        this.setTo(0, 0, 0, 0, 0, 0);\n      }\n    }\n\n    /**\n     * The size of the Cube object, expressed as a Point3 object with the values of the widthX, widthY and height properties.\n     * @method Cube.size\n     * @param {Cube} a - The Cube object.\n     * @param {Point3} [output] - Optional Point3 object. If given the values will be set into the object, otherwise a brand new Point3 object will be created and returned.\n     * @return {Point3} The size of the Cube object\n     */\n\n  }], [{\n    key: 'size',\n    value: function size(a, output) {\n      if (typeof output === 'undefined' || output === null) {\n        output = new _Point2.default(a.widthX, a.widthY, a.height);\n      } else {\n        output.setTo(a.widthX, a.widthY, a.height);\n      }\n\n      return output;\n    }\n\n    /**\n     * Returns a new Cube object with the same values for the x, y, z, widthX, widthY, and height properties as the original Cube object.\n     * @method Cube.clone\n     * @param {Cube} a - The Cube object.\n     * @param {Cube} [output] - Optional Cube object. If given the values will be set into the object, otherwise a brand new Cube object will be created and returned.\n     * @return {Cube}\n     */\n\n  }, {\n    key: 'clone',\n    value: function clone(a, output) {\n      if (typeof output === 'undefined' || output === null) {\n        output = new Cube(a.x, a.y, a.z, a.widthX, a.widthY, a.height);\n      } else {\n        output.setTo(a.x, a.y, a.z, a.widthX, a.widthY, a.height);\n      }\n\n      return output;\n    }\n\n    /**\n     * Determines whether the specified coordinates are contained within the region defined by this Cube object.\n     * @method Cube.contains\n     * @param {Cube} a - The Cube object.\n     * @param {number} x - The x coordinate of the point to test.\n     * @param {number} y - The y coordinate of the point to test.\n     * @param {number} z - The z coordinate of the point to test.\n     * @return {boolean} A value of true if the Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(a, x, y, z) {\n      if (a.widthX <= 0 || a.widthY <= 0 || a.height <= 0) {\n        return false;\n      }\n\n      return x >= a.x && x <= a.frontX && y >= a.y && y <= a.frontY && z >= a.z && z <= a.top;\n    }\n\n    /**\n     * Determines whether the specified X and Y coordinates are contained within the region defined by this Cube object.\n     * @method Cube.containsXY\n     * @param {Cube} a - The Cube object.\n     * @param {number} x - The x coordinate of the point to test.\n     * @param {number} y - The y coordinate of the point to test.\n     * @return {boolean} A value of true if the Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'containsXY',\n    value: function containsXY(a, x, y) {\n      if (a.widthX <= 0 || a.widthY <= 0) {\n        return false;\n      }\n\n      return x >= a.x && x <= a.frontX && y >= a.y && y <= a.frontY;\n    }\n\n    /**\n     * Determines whether the specified point is contained within the cubic region defined by this Cube object. This method is similar to the Cube.contains() method, except that it takes a Point3 object as a parameter.\n     * @method Cube.containsPoint3\n     * @param {Cube} a - The Cube object.\n     * @param {Point3} point3 - The Point3 object being checked. Can be Point3 or any object with .x, .y and .z values.\n     * @return {boolean} A value of true if the Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'containsPoint3',\n    value: function containsPoint3(a, point3) {\n      return Cube.contains(a, point3.x, point3.y, point3.z);\n    }\n\n    /**\n     * Determines whether the first Cube object is fully contained within the second Cube object.\n     * A Cube object is said to contain another if the second Cube object falls entirely within the boundaries of the first.\n     * @method Cube.containsCube\n     * @param {Cube} a - The first Cube object.\n     * @param {Cube} b - The second Cube object.\n     * @return {boolean} A value of true if the Cube object contains the specified point; otherwise false.\n     */\n\n  }, {\n    key: 'containsCube',\n    value: function containsCube(a, b) {\n      //  If the given cube has a larger volume than this one then it can never contain it\n      if (a.volume > b.volume) {\n        return false;\n      }\n\n      return a.x >= b.x && a.y >= b.y && a.z >= b.z && a.frontX <= b.frontX && a.frontY <= b.frontY && a.top <= b.top;\n    }\n\n    /**\n     * Determines whether the two Cubes intersect with each other.\n     * This method checks the x, y, z, widthX, widthY, and height properties of the Cubes.\n     * @method Cube.intersects\n     * @param {Cube} a - The first Cube object.\n     * @param {Cube} b - The second Cube object.\n     * @return {boolean} A value of true if the specified object intersects with this Cube object; otherwise false.\n     */\n\n  }, {\n    key: 'intersects',\n    value: function intersects(a, b) {\n      if (a.widthX <= 0 || a.widthY <= 0 || a.height <= 0 || b.widthX <= 0 || b.widthY <= 0 || b.height <= 0) {\n        return false;\n      }\n      return !(a.frontX < b.x || a.frontY < b.y || a.x > b.frontX || a.y > b.frontY || a.z > b.top || a.top < b.z);\n    }\n  }]);\n\n  return Cube;\n}();\n\nexports.default = Cube;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/Cube.js?");

/***/ }),

/***/ "./src/IsoSprite.js":
/*!**************************!*\
  !*** ./src/IsoSprite.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _IsometricPlugin = __webpack_require__(/*! ./IsometricPlugin */ \"./src/IsometricPlugin.js\");\n\nvar _Point = __webpack_require__(/*! ./Point3 */ \"./src/Point3.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Cube = __webpack_require__(/*! ./Cube */ \"./src/Cube.js\");\n\nvar _Cube2 = _interopRequireDefault(_Cube);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n* @class IsoSprite\n*\n* @classdesc\n* Create a new `IsoSprite` object. IsoSprites are extended versions of standard Sprites that are suitable for axonometric positioning.\n*\n* IsoSprites are simply Sprites that have three new position properties (isoX, isoY and isoZ) and ask the instance of Projector what their position should be in a 2D scene whenever these properties are changed.\n* The IsoSprites retain their 2D position property to prevent any problems and allow you to interact with them as you would a normal Sprite. The upside of this simplicity is that things should behave predictably for those already used to Phaser.\n*/\nvar IsoSprite = function (_Phaser$GameObjects$S) {\n  _inherits(IsoSprite, _Phaser$GameObjects$S);\n\n  /**\n   * @constructor\n   * @extends Phaser.GameObjects.Sprite\n   * @param {Phaser.Game} game - A reference to the currently running game.\n   * @param {number} x - The x coordinate (in 3D space) to position the IsoSprite at.\n   * @param {number} y - The y coordinate (in 3D space) to position the IsoSprite at.\n   * @param {number} z - The z coordinate (in 3D space) to position the IsoSprite at.\n   * @param {string|Phaser.RenderTexture|Phaser.BitmapData|PIXI.Texture} key - This is the image or texture used by the IsoSprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n   * @param {string|number} frame - If this IsoSprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a string or numeric index.\n   */\n  function IsoSprite(scene, x, y, z, texture, frame) {\n    _classCallCheck(this, IsoSprite);\n\n    /**\n     * @property {number} type - The const type of this object.\n     * @readonly\n     */\n    var _this = _possibleConstructorReturn(this, (IsoSprite.__proto__ || Object.getPrototypeOf(IsoSprite)).call(this, scene, x, y, texture, frame));\n\n    _this.type = _IsometricPlugin.ISOSPRITE;\n\n    /**\n     * @property {Point3} _isoPosition - Internal 3D position.\n     * @private\n     */\n    _this._isoPosition = new _Point2.default(x, y, z);\n\n    /**\n     * @property {number} snap - Snap this IsoSprite's position to the specified value; handy for keeping pixel art snapped to whole pixels.\n     * @default\n     */\n    _this.snap = 0;\n\n    /**\n     * @property {boolean} _isoPositionChanged - Internal invalidation control for positioning.\n     * @readonly\n     * @private\n     */\n    _this._isoPositionChanged = true;\n\n    /**\n     * @property {boolean} _isoBoundsChanged - Internal invalidation control for isometric bounds.\n     * @readonly\n     * @private\n     */\n    _this._isoBoundsChanged = true;\n\n    _this._project();\n\n    /**\n     * @property {Cube} _isoBounds - Internal derived 3D bounds.\n     * @private\n     */\n    _this._isoBounds = _this.resetIsoBounds();\n    return _this;\n  }\n\n  /**\n   * The axonometric position of the IsoSprite on the x axis. Increasing the x coordinate will move the object down and to the right on the screen.\n   *\n   * @name IsoSprite#isoX\n   * @property {number} isoX - The axonometric position of the IsoSprite on the x axis.\n   */\n\n\n  _createClass(IsoSprite, [{\n    key: '_project',\n\n\n    /**\n     * Internal function that performs the axonometric projection from 3D to 2D space.\n     * @method Phaser.Plugin.Isometric.IsoSprite#_project\n     * @memberof Phaser.Plugin.Isometric.IsoSprite\n     * @private\n     */\n    value: function _project() {\n      if (this._isoPositionChanged) {\n        var _scene$isometric$proj = this.scene.isometric.project(this._isoPosition, this.position),\n            x = _scene$isometric$proj.x,\n            y = _scene$isometric$proj.y;\n\n        this.x = x;\n        this.y = y;\n        this.depth = this._isoPosition.x + this._isoPosition.y + this._isoPosition.z * 1.25;\n\n        if (this.snap > 0) {\n          this.x = Phaser.Math.snapTo(this.x, this.snap);\n          this.y = Phaser.Math.snapTo(this.y, this.snap);\n        }\n\n        this._isoPositionChanged = this._isoBoundsChanged = true;\n      }\n    }\n\n    /**\n     * Internal function called by the World preUpdate cycle.\n     *\n     * @method IsoSprite#preUpdate\n     * @memberof IsoSprite\n     */\n\n  }, {\n    key: 'preUpdate',\n    value: function preUpdate() {\n      Phaser.GameObjects.Sprite.prototype.preUpdate.call(this);\n\n      this._project();\n    }\n  }, {\n    key: 'resetIsoBounds',\n    value: function resetIsoBounds() {\n      if (typeof this._isoBounds === 'undefined') {\n        this._isoBounds = new _Cube2.default();\n      }\n\n      var asx = Math.abs(this.scaleX);\n      var asy = Math.abs(this.scaleY);\n\n      this._isoBounds.widthX = Math.round(Math.abs(this.width) * 0.5) * asx;\n      this._isoBounds.widthY = Math.round(Math.abs(this.width) * 0.5) * asx;\n      this._isoBounds.height = Math.round(Math.abs(this.height) - Math.abs(this.width) * 0.5) * asy;\n\n      this._isoBounds.x = this.isoX + this._isoBounds.widthX * -this.originX + this._isoBounds.widthX * 0.5;\n      this._isoBounds.y = this.isoY + this._isoBounds.widthY * this.originX - this._isoBounds.widthY * 0.5;\n      this._isoBounds.z = this.isoZ - Math.abs(this.height) * (1 - this.originY) + Math.abs(this.width * 0.5);\n\n      return this._isoBounds;\n    }\n  }, {\n    key: 'isoX',\n    get: function get() {\n      return this._isoPosition.x;\n    },\n    set: function set(value) {\n      this._isoPosition.x = value;\n      this._isoPositionChanged = this._isoBoundsChanged = true;\n      if (this.body) {\n        this.body._reset = true;\n      }\n    }\n\n    /**\n     * The axonometric position of the IsoSprite on the y axis. Increasing the y coordinate will move the object down and to the left on the screen.\n     *\n     * @name IsoSprite#isoY\n     * @property {number} isoY - The axonometric position of the IsoSprite on the y axis.\n     */\n\n  }, {\n    key: 'isoY',\n    get: function get() {\n      return this._isoPosition.y;\n    },\n    set: function set(value) {\n      this._isoPosition.y = value;\n      this._isoPositionChanged = this._isoBoundsChanged = true;\n\n      if (this.body) {\n        this.body._reset = true;\n      }\n    }\n\n    /**\n     * The axonometric position of the IsoSprite on the z axis. Increasing the z coordinate will move the object directly upwards on the screen.\n     *\n     * @name Phaser.Plugin.Isometric.IsoSprite#isoZ\n     * @property {number} isoZ - The axonometric position of the IsoSprite on the z axis.\n     */\n\n  }, {\n    key: 'isoZ',\n    get: function get() {\n      return this._isoPosition.z;\n    },\n    set: function set(value) {\n      this._isoPosition.z = value;\n      this._isoPositionChanged = this._isoBoundsChanged = true;\n      if (this.body) {\n        this.body._reset = true;\n      }\n    }\n\n    /**\n     * A Point3 object representing the axonometric position of the IsoSprite.\n     *\n     * @name Phaser.Plugin.Isometric.IsoSprite#isoPosition\n     * @property {Point3} isoPosition - The axonometric position of the IsoSprite.\n     * @readonly\n     */\n\n  }, {\n    key: 'isoPosition',\n    get: function get() {\n      return this._isoPosition;\n    }\n\n    /**\n     * A Cube object representing the derived boundsof the IsoSprite.\n     *\n     * @name Phaser.Plugin.Isometric.IsoSprite#isoBounds\n     * @property {Point3} isoBounds - The derived 3D bounds of the IsoSprite.\n     * @readonly\n     */\n\n  }, {\n    key: 'isoBounds',\n    get: function get() {\n      if (this._isoBoundsChanged || !this._isoBounds) {\n        this.resetIsoBounds();\n        this._isoBoundsChanged = false;\n      }\n\n      return this._isoBounds;\n    }\n  }]);\n\n  return IsoSprite;\n}(Phaser.GameObjects.Sprite);\n\n/**\n * Create a new IsoSprite with specific position and sprite sheet key.\n *\n * @method Phaser.GameObjectFactory#isoSprite\n * @param {number} x - X position of the new IsoSprite.\n * @param {number} y - Y position of the new IsoSprite.\n * @param {number} y - Z position of the new IsoSprite.\n * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.\n * @returns {IsoSprite} the newly created IsoSprite object.\n */\n\nPhaser.GameObjects.GameObjectCreator.register('isoSprite', function (x, y, z, key, frame) {\n  return new IsoSprite(this.scene, x, y, z, key, frame);\n});\n\n/**\n * Create a new IsoSprite with specific position and sprite sheet key.\n *\n * @method Phaser.GameObjectFactory#isoSprite\n * @param {number} x - X position of the new IsoSprite.\n * @param {number} y - Y position of the new IsoSprite.\n * @param {number} y - Z position of the new IsoSprite.\n * @param {string|Phaser.RenderTexture|PIXI.Texture} key - This is the image or texture used by the Sprite during rendering. It can be a string which is a reference to the Cache entry, or an instance of a RenderTexture or PIXI.Texture.\n * @param {string|number} [frame] - If the sprite uses an image from a texture atlas or sprite sheet you can pass the frame here. Either a number for a frame ID or a string for a frame name.\n * @param {Phaser.Group} [group] - Optional Group to add the object to. If not specified it will be added to the World group.\n * @returns {IsoSprite} the newly created IsoSprite object.\n */\nPhaser.GameObjects.GameObjectFactory.register('isoSprite', function (x, y, z, key) {\n  var frame = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var group = arguments[5];\n\n  var sprite = new IsoSprite(this.scene, x, y, z, key, frame);\n\n  if (typeof group === 'undefined') {\n    this.displayList.add(sprite);\n    this.updateList.add(sprite);\n  } else {\n    group.add(sprite, true);\n  }\n\n  return sprite;\n});\n\n// Phaser.Utils.Debug.prototype.isoSprite = function (sprite, color, filled) {\n//\n//   if (!sprite.isoBounds) {\n//     return;\n//   }\n//\n//   if (typeof filled === 'undefined') {\n//     filled = true;\n//   }\n//\n//   color = color || 'rgba(0,255,0,0.4)';\n//\n//\n//   var points = [],\n//     corners = sprite.isoBounds.getCorners();\n//\n//   var posX = -sprite.game.camera.x;\n//   var posY = -sprite.game.camera.y;\n//\n//   this.start();\n//\n//   if (filled) {\n//     points = [corners[1], corners[3], corners[2], corners[6], corners[4], corners[5], corners[1]];\n//\n//     points = points.map(function (p) {\n//       var newPos = sprite.game.iso.project(p);\n//       newPos.x += posX;\n//       newPos.y += posY;\n//       return newPos;\n//     });\n//     this.context.beginPath();\n//     this.context.fillStyle = color;\n//     this.context.moveTo(points[0].x, points[0].y);\n//\n//     for (var i = 1; i < points.length; i++) {\n//       this.context.lineTo(points[i].x, points[i].y);\n//     }\n//     this.context.fill();\n//   } else {\n//     points = corners.slice(0, corners.length);\n//     points = points.map(function (p) {\n//       var newPos = sprite.game.iso.project(p);\n//       newPos.x += posX;\n//       newPos.y += posY;\n//       return newPos;\n//     });\n//\n//     this.context.moveTo(points[0].x, points[0].y);\n//     this.context.beginPath();\n//     this.context.strokeStyle = color;\n//\n//     this.context.lineTo(points[1].x, points[1].y);\n//     this.context.lineTo(points[3].x, points[3].y);\n//     this.context.lineTo(points[2].x, points[2].y);\n//     this.context.lineTo(points[6].x, points[6].y);\n//     this.context.lineTo(points[4].x, points[4].y);\n//     this.context.lineTo(points[5].x, points[5].y);\n//     this.context.lineTo(points[1].x, points[1].y);\n//     this.context.lineTo(points[0].x, points[0].y);\n//     this.context.lineTo(points[4].x, points[4].y);\n//     this.context.moveTo(points[0].x, points[0].y);\n//     this.context.lineTo(points[2].x, points[2].y);\n//     this.context.moveTo(points[3].x, points[3].y);\n//     this.context.lineTo(points[7].x, points[7].y);\n//     this.context.lineTo(points[6].x, points[6].y);\n//     this.context.moveTo(points[7].x, points[7].y);\n//     this.context.lineTo(points[5].x, points[5].y);\n//     this.context.stroke();\n//     this.context.closePath();\n//   }\n//\n//   this.stop();\n//\n// };\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/IsoSprite.js?");

/***/ }),

/***/ "./src/IsometricPlugin.js":
/*!********************************!*\
  !*** ./src/IsometricPlugin.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ISOARCADE = exports.ISOSPRITE = exports.BACKWARDY = exports.BACKWARDX = exports.FORWARDY = exports.FORWARDX = exports.DOWN = exports.UP = exports.VERSION = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * The MIT License (MIT)\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Copyright (c) 2015 Lewis Lane\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * Permission is hereby granted, free of charge, to any person obtaining a copy\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * of this software and associated documentation files (the \"Software\"), to deal\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * in the Software without restriction, including without limitation the rights\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * copies of the Software, and to permit persons to whom the Software is\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * furnished to do so, subject to the following conditions:\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * The above copyright notice and this permission notice shall be included in\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * all copies or substantial portions of the Software.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     * THE SOFTWARE.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */\n\n/**\n * @author       Lewis Lane <lew@rotates.org>\n * @copyright    2015 Lewis Lane (Rotates.org)\n * @license      {@link http://opensource.org/licenses/MIT|MIT License}\n */\n\nvar _Projector = __webpack_require__(/*! ./Projector */ \"./src/Projector.js\");\n\nvar _Projector2 = _interopRequireDefault(_Projector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar VERSION = exports.VERSION = '0.9.3';\n\n// Directional consts\nvar UP = exports.UP = 0;\nvar DOWN = exports.DOWN = 1;\nvar FORWARDX = exports.FORWARDX = 2;\nvar FORWARDY = exports.FORWARDY = 3;\nvar BACKWARDX = exports.BACKWARDX = 4;\nvar BACKWARDY = exports.BACKWARDY = 5;\n\n//  Type consts\nvar ISOSPRITE = exports.ISOSPRITE = 'IsoSprite';\nvar ISOARCADE = exports.ISOARCADE = 'IsoArcade';\n\n/**\n * @class IsometricPlugin\n * \n * @classdesc\n * Isometric is a comprehensive axonometric plugin for Phaser which provides an API for handling axonometric projection of assets in 3D space to the screen.\n * The goal has been to mimic as closely as possible the existing APIs provided by Phaser for standard orthogonal 2D projection, but add a third dimension.\n * Also included is an Arcade-based 3D AABB physics engine, which again is closely equivalent in functionality and its API.\n */\n\nvar IsometricPlugin = function () {\n  /**\n   * @constructor\n   * @param {Phaser.Scene} scene The current scene instance\n   */\n  function IsometricPlugin(scene) {\n    _classCallCheck(this, IsometricPlugin);\n\n    this.scene = scene;\n    this.systems = scene.sys;\n\n    if (!scene.sys.settings.isBooted) {\n      scene.sys.events.once('boot', this.boot, this);\n    }\n\n    this.projector = new _Projector2.default(scene, scene.isometricType);\n    scene.isometric = scene.isometric || this.projector;\n  }\n\n  _createClass(IsometricPlugin, [{\n    key: 'boot',\n    value: function boot() {}\n  }, {\n    key: 'addIsoSprite',\n    value: function addIsoSprite(x, y, z, key, frame, group) {\n      return Phaser.GameObjects.GameObjectFactory.prototype.isoSprite(this.scene, x, y, z, key, frame, group);\n    }\n  }], [{\n    key: 'register',\n    value: function register(PluginManager) {\n      PluginManager.register('IsometricPlugin', IsometricPlugin, 'isometric');\n    }\n  }]);\n\n  return IsometricPlugin;\n}();\n\nexports.default = IsometricPlugin;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/IsometricPlugin.js?");

/***/ }),

/***/ "./src/Point3.js":
/*!***********************!*\
  !*** ./src/Point3.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class Point3\n *\n * @classdesc\n * The Point3 object represents a location in a three-dimensional coordinate system,\n * where x and y represent the horizontal axes and z represents the vertical axis.\n * The following code creates a point at (0,0,0):\n * `var myPoint = new Point3();`\n *\n * Creates a new Point3 object. If you pass no parameters a Point3 is created set to (0, 0, 0).\n */\nvar Point3 = function () {\n  /**\n   * @constructor\n   * @param {number} [x=0] - The horizontal X position of this Point.\n   * @param {number} [y=0] - The horizontal Y position of this Point.\n   * @param {number} [z=0] - The vertical position of this Point.\n   */\n  function Point3() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, Point3);\n\n    /**\n     * @property {number} x - The x value of the point.\n     */\n    this.x = x;\n\n    /**\n     * @property {number} y - The y value of the point.\n     */\n    this.y = y;\n\n    /**\n     * @property {number} z - The z value of the point.\n     */\n    this.z = z;\n  }\n\n  /**\n   * Copies the x, y and z properties from any given object to this Point3.\n   *\n   * @method Point3#copyFrom\n   * @param {any} source - The object to copy from.\n   * @return {Point3} This Point3 object.\n   */\n\n\n  _createClass(Point3, [{\n    key: 'copyFrom',\n    value: function copyFrom(source) {\n      return this.setTo(source.x, source.y, source.z);\n    }\n\n    /**\n     * Copies the x, y and z properties from this Point3 to any given object.\n     *\n     * @method Point3#copyTo\n     * @param {any} dest - The object to copy to.\n     * @return {Object} The dest object.\n     */\n\n  }, {\n    key: 'copyTo',\n    value: function copyTo(dest) {\n      dest.x = this.x;\n      dest.y = this.y;\n      dest.z = this.z;\n\n      return dest;\n    }\n\n    /**\n     * Determines whether the given object's x/y/z values are equal to this Point3 object.\n     *\n     * @method Point3#equals\n     * @param {Point3|any} a - The object to compare with this Point3.\n     * @return {boolean} A value of true if the x and y points are equal, otherwise false.\n     */\n\n  }, {\n    key: 'equals',\n    value: function equals(a) {\n      return a.x === this.x && a.y === this.y && a.z === this.z;\n    }\n\n    /**\n     * Sets the x, y and z values of this Point3 object to the given values.\n     * If you omit the y and z value then the x value will be applied to all three, for example:\n     * `Point3.set(2)` is the same as `Point3.set(2, 2, 2)`\n     * If however you set both x and y, but no z, the z value will be set to 0.\n     *\n     * @method Point3#set\n     * @param {number} x - The x value of this point.\n     * @param {number} [y] - The y value of this point. If not given the x value will be used in its place.\n     * @param {number} [z] - The z value of this point. If not given and the y value is also not given, the x value will be used in its place.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'set',\n    value: function set(x, y, z) {\n      this.x = x || 0;\n      this.y = y || (y !== 0 ? this.x : 0);\n      this.z = z || (typeof y === 'undefined' ? this.x : 0);\n    }\n\n    /**\n     * Sets the x, y and z values of this Point3 object to the given values.\n     * If you omit the y and z value then the x value will be applied to all three, for example:\n     * `Point3.setTo(2)` is the same as `Point3.setTo(2, 2, 2)`\n     * If however you set both x and y, but no z, the z value will be set to 0.\n     *\n     * @method Point3#setTo\n     * @param {number} x - The x value of this point.\n     * @param {number} [y] - The y value of this point. If not given the x value will be used in its place.\n     * @param {number} [z] - The z value of this point. If not given and the y value is also not given, the x value will be used in its place.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'setTo',\n    value: function setTo(x, y, z) {\n      return this.set(x, y, z);\n    }\n\n    /**\n     * Adds the given x, y and z values to this Point3.\n     *\n     * @method Point3#add\n     * @param {number} x - The value to add to Point3.x.\n     * @param {number} y - The value to add to Point3.y.\n     * @param {number} z - The value to add to Point3.z.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'add',\n    value: function add(x, y, z) {\n      this.x += x || 0;\n      this.y += y || 0;\n      this.z += z || 0;\n\n      return this;\n    }\n\n    /**\n     * Subtracts the given x, y and z values from this Point3.\n     *\n     * @method Point3#subtract\n     * @param {number} x - The value to subtract from Point3.x.\n     * @param {number} y - The value to subtract from Point3.y.\n     * @param {number} z - The value to subtract from Point3.z.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'subtract',\n    value: function subtract(x, y, z) {\n      this.x -= x || 0;\n      this.y -= y || 0;\n      this.z -= z || 0;\n\n      return this;\n    }\n\n    /**\n     * Multiplies Point3.x, Point3.y and Point3.z by the given x and y values. Sometimes known as `Scale`.\n     *\n     * @method Point3#multiply\n     * @param {number} x - The value to multiply Point3.x by.\n     * @param {number} y - The value to multiply Point3.y by.\n     * @param {number} z - The value to multiply Point3.z by.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'multiply',\n    value: function multiply(x, y, z) {\n      this.x *= x || 1;\n      this.y *= y || 1;\n      this.z *= z || 1;\n\n      return this;\n    }\n\n    /**\n     * Divides Point3.x, Point3.y and Point3.z by the given x, y and z values.\n     *\n     * @method Point3#divide\n     * @param {number} x - The value to divide Point3.x by.\n     * @param {number} y - The value to divide Point3.y by.\n     * @param {number} z - The value to divide Point3.z by.\n     * @return {Point3} This Point3 object. Useful for chaining method calls.\n     */\n\n  }, {\n    key: 'divide',\n    value: function divide(x, y, z) {\n      this.x /= x || 1;\n      this.y /= y || 1;\n      this.z /= z || 1;\n\n      return this;\n    }\n\n    /**\n     * Adds the coordinates of two points together to create a new point.\n     *\n     * @method Point3.add\n     * @param {Point3} a - The first Point3 object.\n     * @param {Point3} b - The second Point3 object.\n     * @param {Point3} [out] - Optional Point3 to store the value in, if not supplied a new Point3 object will be created.\n     * @return {Point3} The new Point3 object.\n     */\n\n  }], [{\n    key: 'add',\n    value: function add(a, b) {\n      var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point3();\n\n      out.x = a.x + b.x;\n      out.y = a.y + b.y;\n      out.z = a.z + b.z;\n\n      return out;\n    }\n\n    /**\n     * Subtracts the coordinates of two points to create a new point.\n     *\n     * @method Point3.subtract\n     * @param {Point3} a - The first Point3 object.\n     * @param {Point3} b - The second Point3 object.\n     * @param {Point3} [out] - Optional Point3 to store the value in, if not supplied a new Point3 object will be created.\n     * @return {Point3} The new Point3 object.\n     */\n\n  }, {\n    key: 'subtract',\n    value: function subtract(a, b) {\n      var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point3();\n\n      out.x = a.x - b.x;\n      out.y = a.y - b.y;\n      out.z = a.z - b.z;\n\n      return out;\n    }\n\n    /**\n     * Multiplies the coordinates of two points to create a new point.\n     *\n     * @method Point3.multiply\n     * @param {Point3} a - The first Point3 object.\n     * @param {Point3} b - The second Point3 object.\n     * @param {Point3} [out] - Optional Point3 to store the value in, if not supplied a new Point3 object will be created.\n     * @return {Point3} The new Point3 object.\n     */\n\n  }, {\n    key: 'multiply',\n    value: function multiply(a, b) {\n      var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point3();\n\n      out.x = a.x * b.x;\n      out.y = a.y * b.y;\n      out.z = a.z * b.z;\n\n      return out;\n    }\n\n    /**\n     * Divides the coordinates of two points to create a new point.\n     *\n     * @method Point3.divide\n     * @param {Point3} a - The first Point3 object.\n     * @param {Point3} b - The second Point3 object.\n     * @param {Point3} [out] - Optional Point3 to store the value in, if not supplied a new Point3 object3 will be created.\n     * @return {Point3} The new Point3 object.\n     */\n\n  }, {\n    key: 'divide',\n    value: function divide(a, b) {\n      var out = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point3();\n\n      out.x = a.x / b.x;\n      out.y = a.y / b.y;\n      out.z = a.z / b.z;\n\n      return out;\n    }\n\n    /**\n     * Determines whether the two given Point3 objects are equal. They are considered equal if they have the same x, y and z values.\n     *\n     * @method Point3.equals\n     * @param {Point3} a - The first Point3 object.\n     * @param {Point3} b - The second Point3 object.\n     * @return {boolean} A value of true if the Points3 are equal, otherwise false.\n     */\n\n  }, {\n    key: 'equals',\n    value: function equals(a, b) {\n      return a.x === b.x && a.y === b.y && a.z === b.z;\n    }\n  }]);\n\n  return Point3;\n}();\n\nexports.default = Point3;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/Point3.js?");

/***/ }),

/***/ "./src/Projector.js":
/*!**************************!*\
  !*** ./src/Projector.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MILITARY = exports.ISOMETRIC = exports.CLASSIC = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Point = __webpack_require__(/*! ./Point3 */ \"./src/Point3.js\");\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//  Projection angles\nvar CLASSIC = exports.CLASSIC = Math.atan(0.5);\nvar ISOMETRIC = exports.ISOMETRIC = Math.PI / 6;\nvar MILITARY = exports.MILITARY = Math.PI / 4;\n\n/**\n * @class Projector\n *\n * @classdesc\n * Creates a new Isometric Projector object, which has helpers for projecting x, y and z coordinates into axonometric x and y equivalents.\n */\n\nvar Projector = function () {\n  /**\n  * @constructor\n  * @param {Phaser.Game} game - The current game object.\n  * @param {number} projectionAngle - The angle of the axonometric projection in radians. Defaults to approx. 0.4636476 (Math.atan(0.5) which is suitable for 2:1 pixel art dimetric)\n  * @return {Phaser.Plugin.Isometric.Cube} This Cube object.\n  */\n  function Projector(scene, projectionAngle) {\n    _classCallCheck(this, Projector);\n\n    /**\n     * @property {Phaser.Scene} scne - The current scene object.\n     */\n    this.scene = scene;\n\n    /**\n     * @property {array} _transform - The pre-calculated axonometric transformation values.\n     * @private\n     */\n    this._transform = null;\n\n    /**\n     * @property {number} _projectionAngle - The cached angle of projection in radians.\n     * @private\n     */\n    this._projectionAngle = 0;\n\n    /**\n     * @property {number} projectionAngle - The angle of projection in radians.\n     * @default\n     */\n    this.projectionAngle = projectionAngle || CLASSIC;\n\n    /**\n     * @property {Phaser.Point} anchor - The x and y offset multipliers as a ratio of the game world size.\n     * @default\n     */\n    this.anchor = new Phaser.Geom.Point(0.5, 0);\n  }\n\n  /**\n   * @name Phaser.Plugin.Isometric.Projector#projectionAngle\n   * @property {number} projectionAngle - The angle of axonometric projection.\n   */\n\n\n  _createClass(Projector, [{\n    key: 'project',\n\n\n    /**\n     * Use axonometric projection to transform a 3D Point3 coordinate to a 2D Point coordinate. If given the coordinates will be set into the object, otherwise a brand new Point object will be created and returned.\n     * @method Phaser.Plugin.Isometric.Projector#project\n     * @param {Phaser.Plugin.Isometric.Point3} point3 - The Point3 to project from.\n     * @param {Phaser.Point} out - The Point to project to.\n     * @return {Phaser.Point} The transformed Point.\n     */\n    value: function project(point3) {\n      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Phaser.Geom.Point();\n\n      out.x = (point3.x - point3.y) * this._transform[0];\n      out.y = (point3.x + point3.y) * this._transform[1] - point3.z;\n\n      var _scene$sys$game$confi = this.scene.sys.game.config,\n          width = _scene$sys$game$confi.width,\n          height = _scene$sys$game$confi.height;\n\n      out.x += width * this.anchor.x;\n      out.y += height * this.anchor.y;\n\n      return out;\n    }\n\n    /**\n     * Use axonometric projection to transform a 3D Point3 coordinate to a 2D Point coordinate, ignoring the z-axis. If given the coordinates will be set into the object, otherwise a brand new Point object will be created and returned.\n     * @method Phaser.Plugin.Isometric.Projector#projectXY\n     * @param {Phaser.Plugin.Isometric.Point3} point3 - The Point3 to project from.\n     * @param {Phaser.Point} out - The Point to project to.\n     * @return {Phaser.Point} The transformed Point.\n     */\n\n  }, {\n    key: 'projectXY',\n    value: function projectXY(point3) {\n      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Phaser.Geom.Point();\n\n      out.x = (point3.x - point3.y) * this._transform[0];\n      out.y = (point3.x + point3.y) * this._transform[1];\n\n      out.x += this.game.world.width * this.anchor.x;\n      out.y += this.game.world.height * this.anchor.y;\n\n      return out;\n    }\n\n    /**\n     * Use reverse axonometric projection to transform a 2D Point coordinate to a 3D Point3 coordinate. If given the coordinates will be set into the object, otherwise a brand new Point3 object will be created and returned.\n     * @method Phaser.Plugin.Isometric.Projector#unproject\n     * @param {Phaser.Plugin.Isometric.Point} point - The Point to project from.\n     * @param {Phaser.Plugin.Isometric.Point3} out - The Point3 to project to.\n     * @param {number} [z] - Specified z-plane to project to.\n     * @return {Phaser.Plugin.Isometric.Point3} The transformed Point3.\n     */\n\n  }, {\n    key: 'unproject',\n    value: function unproject(point) {\n      var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _Point2.default();\n      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var x = point.x - this.game.world.x - this.game.world.width * this.anchor.x;\n      var y = point.y - this.game.world.y - this.game.world.height * this.anchor.y + z;\n\n      out.x = x / (2 * this._transform[0]) + y / (2 * this._transform[1]);\n      out.y = -(x / (2 * this._transform[0])) + y / (2 * this._transform[1]);\n      out.z = z;\n\n      return out;\n    }\n  }, {\n    key: 'projectionAngle',\n    set: function set(angle) {\n      if (angle === this._projectionAngle) {\n        return;\n      }\n\n      this._projectionAngle = angle;\n      this._transform = [Math.cos(this._projectionAngle), Math.sin(this._projectionAngle)];\n    },\n    get: function get() {\n      return this._projectionAngle;\n    }\n  }]);\n\n  return Projector;\n}();\n\nexports.default = Projector;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/Projector.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IsoSprite = exports.default = undefined;\n\nvar _IsometricPlugin = __webpack_require__(/*! ./IsometricPlugin */ \"./src/IsometricPlugin.js\");\n\nvar _IsometricPlugin2 = _interopRequireDefault(_IsometricPlugin);\n\nvar _IsoSprite = __webpack_require__(/*! ./IsoSprite */ \"./src/IsoSprite.js\");\n\nvar _IsoSprite2 = _interopRequireDefault(_IsoSprite);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _IsometricPlugin2.default;\nexports.IsoSprite = _IsoSprite2.default;\n\n//# sourceURL=webpack://phaser-plugin-isometric/./src/index.js?");

/***/ }),

/***/ 0:
/*!****************************!*\
  !*** multi ./src/index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./src/index.js */\"./src/index.js\");\n\n\n//# sourceURL=webpack://phaser-plugin-isometric/multi_./src/index.js?");

/***/ })

/******/ });